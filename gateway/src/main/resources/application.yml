server:
  port: 8080

eureka:
  client:
    service-url:
      defaultZone: http://test:test@localhost:8010/eureka
  instance:
    prefer-ip-address: true

spring:
  application:
    name: gateway

  ### we need to configure the routing of the requests which will come to the Gateway, to the microservices

  cloud:
    gateway:
      discovery:
        # automatic routing of gateway routes  ->  /microserviceName/RequestMappingOfSpecificController
        # allows the Gateway, to locate the microservices, by using their application.name => not as clean as manually configuring routing, bcs we have to include microservice name in the URL
        locator:
          enabled: true
          lower-case-service-id: true

      ### manually configuring the routing

      routes:
        # describes the endpoint
      - id: users-status-check
        # since the ports are random, I use the lb = load balancer of eureka. this way we can automatically get the port at which the microservice is running
        uri: lb://users-ws
        ## predicates are like if conditions. routing will be done only if true
        # only if request URL path matches, it will be routed successfully
        predicates:
        - Path=/users-ws/users/status/check
        - Method=GET
        # request must have a Bearer token header
        - Header=Authorization, Bearer (.*)
        ## can also apply filters
        filters:
        # this filter removes the cookies, if request has any. bcs we use JWT. THis is built-in method. we can also have custom filters
        - RemoveRequestHeader=Cookie
        # use the custom class as a filter. when requests are made, this filter logic will be applied.
        # will check if jwt token was signed with correct secret key
        - AuthorizationHeaderFilter
        # another useful filter is: RewritePath=pathOfRequestWhichIWantToTransform, transformedPath
        - RewritePath=/users-ws/(?<segment>.*), /$\{segment}

      # register - no need for header auth or filters for jwt
      - id: users-ws
        uri: lb://users-ws
        predicates:
        - Path=/users-ws/users
        - Method=POST
        filters:
        - RemoveRequestHeader=Cookie
        - RewritePath=/users-ws/(?<segment>.*), /$\{segment}

      # login - no need for header auth or filters for jwt
      - id: users-ws-login
        uri: lb://users-ws
        predicates:
        - Path=/users-ws/users/login
        - Method=POST
        filters:
        - RemoveRequestHeader=Cookie
        - RewritePath=/users-ws/(?<segment>.*), /$\{segment}

      # TODO: refresh token

      # get, update users
      - id: users-ws-get-update
        uri: lb://users-ws
        predicates:
        - Path=/users-ws/users/**
        - Method=GET,PUT
        # request must have a Bearer token header
        - Header=Authorization, Bearer (.*)
        filters:
        - RemoveRequestHeader=Cookie
        # will check if jwt token was signed with correct secret key
        - AuthorizationHeaderFilter
        - RewritePath=/users-ws/(?<segment>.*), /$\{segment}

      # actuator for users-microservice
      - id: users-ws-actuator
        uri: lb://users-ws
        predicates:
        - Path=/users-ws/actuator
        - Method=GET
        filters:
        - RemoveRequestHeader=Cookie
        - RewritePath=/users-ws/(?<segment>.*), /$\{segment}

      # add the others


  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest

## Using the Actuator dependency in the gateway, I can expose different endpoints of it, to the client.
# some endpoints are enabled by default, for others I have to enable them like below. exposes the beans of the app, health, routes that are configured
management:
  endpoints:
    web:
      exposure:
        include: beans, health, routes, httptrace


token:
  secret: doni123donald12345donald54321donald321doni